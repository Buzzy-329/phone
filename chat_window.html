<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Chat Window</title>
    <style id="dynamicStyles">
        /* 动态样式插入点 */
    </style>
    <style>
        /* --- 基础设置 --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        body {
            margin: 0; padding: 0; height: 100vh; 
            width: 100%; 
            background-color: #f2f2f6; /* 默认背景，会被动态覆盖 */
            background-size: cover; background-position: center; background-attachment: fixed;
            font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", sans-serif;
            display: flex; flex-direction: column; overflow: hidden;
            -webkit-user-select: none; user-select: none;
        }
        ::-webkit-scrollbar { display: none; }
        * { scrollbar-width: none; -ms-overflow-style: none; }

        /* --- 聊天头部 --- */
        .chat-header {
            height: 110px; 
            padding: 45px 15px 10px 15px; 
            background: rgba(255,255,255,0.9);
            display: grid; grid-template-columns: 44px 1fr auto; align-items: center;
            border-bottom: 1px solid rgba(0,0,0,0.05); backdrop-filter: blur(10px);
            position: fixed; top: 0; left: 0; width: 100%; z-index: 100;
        }
        .back-btn { width: 44px; height: 44px; display: flex; justify-content: flex-start; align-items: center; cursor: pointer; color: #007AFF; }
        .header-center { display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden; }
        .chat-title { font-weight: 600; font-size: 18px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; text-align: center; }
        .chat-status { font-size: 12px; color: #999; margin-top: 4px; display: flex; align-items: center; gap: 4px; cursor: pointer; padding: 2px 8px; border-radius: 10px; transition: background 0.2s; }
        .chat-status:active { background: rgba(0,0,0,0.05); }
        .status-dot { width: 6px; height: 6px; background: #34C759; border-radius: 50%; }
        .chat-title.typing { color: #007AFF; animation: pulseText 1.5s infinite ease-in-out; }
        @keyframes pulseText { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .chat-header-right { display: flex; gap: 5px; }
        .header-icon-btn { width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; cursor: pointer; color: #333; transition: opacity 0.2s; }
        .header-icon-btn:active { opacity: 0.6; }
        .icon { width: 24px; height: 24px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }

        /* --- 聊天内容区 --- */
        .chat-body { flex: 1; padding: 120px 16px 110px 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .msg-time { text-align: center; font-size: 12px; color: #b0b0b0; margin: 15px 0 5px 0; font-weight: 500; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        .msg-system-row { display: flex; justify-content: center; margin: 5px 0; }
        .sys-bubble { background: rgba(0,0,0,0.04); color: #999; font-size: 12px; padding: 4px 12px; border-radius: 10px; max-width: 85%; text-align: center; backdrop-filter: blur(2px); }
        .sys-recall-link { cursor: pointer; color: #5c6b8c; text-decoration: none; }
        
        .msg-row { display: flex; width: 100%; align-items: flex-start; gap: 10px; animation: fadeUp 0.3s ease; }
        @keyframes fadeUp { from{opacity:0;transform:translateY(10px);} to{opacity:1;transform:translateY(0);} }
        .msg-row.ai { flex-direction: row; }
        .msg-row.me { flex-direction: row-reverse; }

        .msg-avatar-box { width: 42px; height: 42px; border-radius: 50%; background: #e0e0e0; flex-shrink: 0; display: flex; justify-content: center; align-items: center; overflow: hidden; box-shadow: 0 1px 2px rgba(0,0,0,0.1); cursor: pointer; }
        .msg-avatar-img { width: 100%; height: 100%; object-fit: cover; }
        .bear-svg { width: 100%; height: 100%; }

        /* --- 气泡样式 (基础) --- */
        .bubble {
            max-width: 72%; padding: 12px 16px; border-radius: 20px; 
            font-size: 16px; line-height: 1.5; word-wrap: break-word; position: relative; margin-top: 2px;
            user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
        }
        /* 默认样式，会被详情页 CSS 覆盖 */
        .msg-row.ai .bubble { background: #fff; color: #333; border-top-left-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.03); }
        .msg-row.me .bubble { background: #0099FF; color: #fff; border-top-right-radius: 4px; }
        
        .reply-block { margin-bottom: 8px; padding: 6px 10px; border-radius: 8px; background: rgba(0,0,0,0.05); font-size: 13px; color: #666; display: flex; flex-direction: column; border-left: 3px solid #ccc; }
        .msg-row.me .reply-block { background: rgba(0,0,0,0.15); color: #e0e0e0; border-left: 3px solid rgba(255,255,255,0.5); }
        .reply-sender { font-weight: 600; font-size: 12px; margin-bottom: 2px; opacity: 0.8; }
        .reply-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; opacity: 0.9; }

        /* --- 底部输入区 --- */
        .input-bar-wrap { position: fixed; bottom: 0; left: 0; right: 0; width: 100%; box-sizing: border-box; min-height: 95px; background: rgba(245, 245, 247, 0.9); padding: 15px 25px 35px 15px; display: flex; align-items: center; gap: 8px; backdrop-filter: blur(20px); border-top: 1px solid rgba(0,0,0,0.05); z-index: 210; }
        .input-field { flex: 1; height: 42px; max-width: 62%; background: #fff; border: 1px solid rgba(0,0,0,0.08); border-radius: 21px; padding: 0 15px; font-size: 16px; }
        .action-btn { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.08); border: none; transition: transform 0.1s; flex-shrink: 0; }
        .action-btn:active { transform: scale(0.9); }
        .btn-plus { background: #fff; color: #333; }
        .btn-reply { background: #fff; color: #6e00ff; } 
        .btn-send { background: #007AFF; color: #fff; } 
        
        .func-frame-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; border: none; z-index: 205; pointer-events: none; display: none; }
        .func-frame-container.active { pointer-events: auto; display: block; }
        .overlay-frame { position: fixed; top: 0; left: 0; width: 100%; height: 100%; border: none; z-index: 900; pointer-events: none; display: none; }
        .overlay-frame.active { pointer-events: auto; display: block; }
        .quote-bar { position: fixed; bottom: 95px; left: 0; width: 100%; background: #f7f7f7; padding: 10px 15px; display: none; align-items: center; justify-content: space-between; color: #666; font-size: 13px; border-top: 1px solid #e0e0e0; z-index: 209; }
        .quote-content { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 10px; }
        .quote-close { width: 20px; height: 20px; color: #999; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 18px; }

        /* --- 弹窗 --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); z-index: 500; display: none; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
        .modal-card { background: rgba(255,255,255,0.98); width: 80%; max-width: 320px; border-radius: 24px; padding: 25px; display: flex; flex-direction: column; gap: 15px; box-shadow: 0 15px 40px rgba(0,0,0,0.15); animation: popIn 0.25s cubic-bezier(0.34, 1.56, 0.64, 1); }
        @keyframes popIn { from{transform:scale(0.85);opacity:0;} to{transform:scale(1);opacity:1;} }
        .modal-title { font-size: 18px; font-weight: 600; text-align: center; color: #333; }
        .modal-msg { font-size: 14px; color: #666; text-align: center; line-height: 1.5; word-wrap: break-word; }
        .modal-input { width: 100%; padding: 12px; background: #f2f2f6; border: none; border-radius: 12px; font-size: 16px; text-align: center; color: #333; }
        .modal-btns { display: flex; gap: 10px; margin-top: 10px; }
        .m-btn { flex: 1; padding: 14px; border-radius: 14px; border: none; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; }
        .m-btn:active { opacity: 0.7; }
        .m-btn.cancel { background: #f2f2f6; color: #888; }
        .m-btn.confirm { background: #333; color: #fff; }
        .m-btn.full-width { width: 100%; }

        .pat-glow .modal-card { box-shadow: 0 0 25px rgba(255, 255, 255, 0.9), 0 10px 30px rgba(0,0,0,0.1); }
        .thoughts-glow .modal-card { box-shadow: 0 0 25px rgba(255, 255, 255, 0.9), 0 10px 30px rgba(0,0,0,0.1); position: relative; min-height: 350px; }
        .close-icon { position: absolute; top: 18px; right: 18px; width: 24px; height: 24px; stroke: #000; stroke-width: 2.5; cursor: pointer; z-index: 10; }
        .history-clock { position: absolute; top: 18px; left: 18px; width: 24px; height: 24px; color: #007AFF; cursor: pointer; z-index: 10; }
        .thoughts-container { flex: 1; display: flex; flex-direction: column; gap: 12px; transition: opacity 0.2s; }
        .thoughts-container.hidden { display: none; }
        .thought-section { background: #f9f9fc; padding: 14px; border-radius: 14px; display: flex; flex-direction: column; gap: 6px; }
        .thought-label { font-size: 11px; color: #ffb7b2; font-weight: 800; letter-spacing: 1px; text-transform: uppercase; }
        .thought-content { font-size: 15px; color: #444; line-height: 1.4; }
        .history-list-view { flex: 1; display: none; flex-direction: column; gap: 10px; overflow-y: auto; max-height: 300px; padding: 5px; }
        .history-list-view.active { display: flex; }
        .history-item { background: #f5f5f7; padding: 12px; border-radius: 12px; display: flex; flex-direction: column; gap: 4px; }
        .h-time { font-size: 11px; color: #aaa; }
        .h-content { font-size: 13px; color: #555; }

/* --- 新增功能样式 --- */

/* 1. 粉色气泡 (转账/语音) */
.bubble.pink-bubble {
    background: #FFDDE3;
    color: #333;
    border: none;
    box-shadow: 0 2px 5px rgba(255, 107, 129, 0.15);
    min-width: 230px; /* 改大到 230px */
    padding: 15px;    /* 稍微增加一点内边距 */
    display: flex; flex-direction: column; gap: 5px;
}
.msg-row.me .bubble.pink-bubble { border-top-right-radius: 4px; }
.msg-row.ai .bubble.pink-bubble { border-top-left-radius: 4px; }

/* 转账卡片内部 */
.transfer-card { display: flex; align-items: center; gap: 10px; }
.transfer-icon-circle {
    width: 36px; height: 36px; background: #FF6B81; border-radius: 50%;
    display: flex; justify-content: center; align-items: center; color: #fff;
    font-size: 18px; font-weight: bold; flex-shrink: 0;
}
.transfer-info { display: flex; flex-direction: column; }
.transfer-amount { font-size: 16px; font-weight: 600; color: #000; }
.transfer-desc { font-size: 12px; color: rgba(0,0,0,0.5); }
.transfer-status { font-size: 10px; color: #FF6B81; margin-top: 4px; text-align: right; font-weight: bold; }

/* 2. 语音条 */
.voice-bubble { display: flex; align-items: center; gap: 8px; cursor: pointer; }
.voice-icon { width: 16px; height: 16px; fill: #FF6B81; }
.voice-duration { font-size: 13px; color: #FF6B81; font-weight: 500; }
.voice-text-content { 
    margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,107,129,0.2); 
    font-size: 13px; color: #555; display: none; 
}
.voice-text-content.show { display: block; }

/* 3. 图片 (灰色小熊) */
.bubble.img-bubble {
    padding: 0; background: transparent !important; box-shadow: none;
    cursor: pointer; overflow: hidden; border-radius: 12px;
}
.bear-img-placeholder {
    width: 120px; height: 120px; background: #e0e0e0;
    display: flex; justify-content: center; align-items: center;
}
.bear-svg-lg { width: 80%; height: 80%; opacity: 0.6; }

/* 图片查看弹窗 (粉色光晕) */
.modal-overlay.img-glow .modal-card {
    box-shadow: 0 0 30px rgba(255, 107, 129, 0.4);
    border: 1px solid rgba(255, 107, 129, 0.2);
}

/* --- 新增：表情面板容器 --- */
.emoticon-frame-container {
    position: fixed;
    bottom: 0; left: 0;
    width: 100%;
    height: 45%; /* 占据屏幕下方约 40-45% */
    border: none;
    z-index: 300; /* 比输入框层级高，或者根据需求调整 */
    border-top-left-radius: 24px;
    border-top-right-radius: 24px;
    box-shadow: 0 -5px 30px rgba(0,0,0,0.1);
    transform: translateY(110%); /* 默认隐藏在底部 */
    transition: transform 0.3s cubic-bezier(0.33, 1, 0.68, 1);
    background: #fff;
    display: none; /* 初始不显示 */
}
.emoticon-frame-container.active {
    display: block;
    transform: translateY(0);
}

/* --- 新增：表情包气泡样式 --- */
.bubble.emo-bubble {
    padding: 0; background: transparent !important; box-shadow: none;
    display: flex; flex-direction: column; align-items: center; gap: 4px;
}
.emo-img {
    max-width: 100px; /* 表情包最大宽度 */
    max-height: 100px;
    border-radius: 8px;
    object-fit: contain;
}
.emo-name-tag {
    font-size: 10px; color: #999;
    padding: 2px 6px; background: rgba(255,255,255,0.5);
    border-radius: 10px; backdrop-filter: blur(2px);
}
.img-desc-text { text-align: center; font-size: 16px; color: #333; font-weight: 500; padding: 20px; }

/* --- 悄悄话 (Whisper) 功能样式 --- */

/* 1. 弹窗容器与背景特效 */
.whisper-modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.4); z-index: 600;
    display: none; justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
}

.whisper-card {
    position: relative;
    width: 85%; max-width: 340px; height: 65%;
    background: #FFF0F5; /* 淡粉色背景 */
    border-radius: 24px;
    box-shadow: 0 0 30px rgba(255, 182, 193, 0.6), 0 0 60px rgba(255, 105, 180, 0.2); /* 粉色光晕 */
    display: flex; flex-direction: column;
    overflow: hidden;
    animation: popIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    border: 2px solid rgba(255, 255, 255, 0.8);
}

/* 闪烁的星星背景容器 */
.stars-container {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 0; overflow: hidden;
}
/* 星星本体 (白色中空五角星 SVG) */
.star-deco {
    position: absolute;
    /* 使用SVG Data URI 绘制中空星星，stroke=white 表示白色边框，fill=none 表示中空 */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolygon points='12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center;
    border: none; /* 移除原来的方框边框 */
    clip-path: none; /* 移除原来的裁剪 */
    opacity: 0; /* 默认隐藏，由动画控制显示 */
    animation: starTwinkle 3s infinite ease-in-out;
}

@keyframes starTwinkle {
    0% { opacity: 0; transform: scale(0.5) rotate(0deg); }
    50% { opacity: 1; transform: scale(1.2) rotate(15deg); } /* 闪烁最亮时变大 */
    100% { opacity: 0; transform: scale(0.5) rotate(30deg); }
}

/* 弹窗头部 */
.whisper-header {
    position: relative; z-index: 2;
    padding: 15px; text-align: center;
    font-size: 18px; font-weight: bold; color: #ff7eb9;
    letter-spacing: 2px;
    text-shadow: 0 2px 4px rgba(255,255,255,0.8);
}
.whisper-close {
    position: absolute; top: 15px; right: 15px;
    width: 24px; height: 24px; color: #ff7eb9;
    cursor: pointer; font-size: 20px; line-height: 24px;
}

/* 便签墙滚动区域 */
.whisper-content-area {
    position: relative; 
    z-index: 2;
    flex: 1; 
    overflow-y: auto;       /* 核心：允许下翻滚动 */
    padding: 15px;
    display: flex;          /* 改动：变为弹性布局 */
    flex-direction: column; /* 改动：方向改为垂直向下，一张张排列 */
    gap: 15px;              /* 保持间距 */
}

/* --- 便签纸样式多样化 --- */
.sticky-note {
    position: relative;
    min-height: 100px;
    padding: 25px 10px 10px 10px; /* 上方留出空间给叉号 */
    box-shadow: 2px 4px 8px rgba(0,0,0,0.1);
    font-size: 13px; line-height: 1.4; color: #555;
    transition: transform 0.2s;
    cursor: default;
    display: flex; align-items: center; justify-content: center;
    text-align: center;
}
.sticky-note:active { transform: scale(0.98); }

/* 便签右上角的叉号 */
.note-delete-btn {
    position: absolute; top: 2px; right: 2px;
    width: 20px; height: 20px;
    color: #ff6b81; font-weight: bold; font-size: 16px;
    cursor: pointer; display: flex; justify-content: center; align-items: center;
    opacity: 0.6;
}
.note-delete-btn:hover { opacity: 1; }

/* 样式1: 粉色爱心底纹 */
.note-style-hearts {
    background-color: #fff0f3;
    background-image: radial-gradient(#ffb3c1 15%, transparent 16%), radial-gradient(#ffb3c1 15%, transparent 16%);
    background-size: 20px 20px;
    background-position: 0 0, 10px 10px;
    border-radius: 2px 2px 15px 2px; /* 右下角卷角效果 */
}
/* 样式2: 棕色底+橙色圆点 */
.note-style-dots {
    background-color: #fdf6e3;
    background-image: radial-gradient(#ffcc80 20%, transparent 20%);
    background-size: 15px 15px;
    border-radius: 2px;
    border-top: 3px solid rgba(255,200,150,0.5); /* 胶带效果 */
}
/* 样式3: 纯白折纸+格子线 */
.note-style-grid {
    background-color: #fff;
    background-image: linear-gradient(#e0e0e0 1px, transparent 1px), linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
    background-size: 20px 20px;
    border: 1px solid #eee;
    transform: rotate(-2deg);
}
/* 样式4: 淡紫色云朵感 */
.note-style-cloud {
    background-color: #f3e5f5;
    border-radius: 12px;
    border: 2px dashed #ce93d8;
}

/* 旋转多样化 (通过JS添加类名) */
.rotate-left { transform: rotate(-3deg); }
.rotate-right { transform: rotate(2deg); }
.rotate-big-left { transform: rotate(-5deg); }
.rotate-big-right { transform: rotate(4deg); }

/* --- 文字样式多样化 --- */
.text-strike { text-decoration: line-through; color: #999; }
.text-bold-pink { font-weight: 800; color: #e91e63; font-size: 14px; }
.text-small { font-size: 11px; color: #777; letter-spacing: 1px; }
.text-bounce { display: inline-block; animation: textBounce 1s infinite alternate; }
@keyframes textBounce { from { transform: translateY(0); } to { transform: translateY(-2px); } }
.text-messy { font-family: "Courier New", Courier, monospace; letter-spacing: -1px; }
/* --- 修复删除确认弹窗被遮挡的问题 --- */
#deleteNoteConfirmModal {
    z-index: 650 !important; /* 让它比悄悄话界面(600)更高 */
}


    </style>
</head>
<body>

    <!-- 悄悄话弹窗 -->
<div class="whisper-modal-overlay" id="whisperModal">
    <div class="whisper-card">
        <!-- 动态星星背景 -->
        <div class="stars-container" id="starsBg">
            <!-- JS 会在这里生成星星 -->
        </div>
        
        <div class="whisper-header">
            悄悄话
            <div class="whisper-close" onclick="document.getElementById('whisperModal').style.display='none'">×</div>
        </div>
        
        <div class="whisper-content-area" id="whisperNoteWall">
            <!-- 便签会动态插入到这里 -->
        </div>
    </div>
</div>

<!-- 删除确认弹窗 (复用现有样式结构，ID区分) -->
<div class="modal-overlay" id="deleteNoteConfirmModal">
    <div class="modal-card">
        <div class="modal-title">删除便签</div>
        <div class="modal-msg">确定要撕掉这张便签吗？</div>
        <div class="modal-btns">
            <button class="m-btn cancel" onclick="document.getElementById('deleteNoteConfirmModal').style.display='none'">取消</button>
            <button class="m-btn confirm" style="background:#ff6b81;" onclick="confirmDeleteNote()">撕掉</button>
        </div>
    </div>
</div>
    
    <div class="quote-bar" id="quoteBar">
        <div class="quote-content" id="quoteText">引用: ...</div>
        <div class="quote-close" onclick="cancelQuote()">×</div>
    </div>

    <iframe id="menuFrame" class="overlay-frame" src="qq_func_menu.html"></iframe>
    <iframe id="listenFrame" class="overlay-frame" src="qq_func_listen.html" style="z-index: 800;"></iframe>

    <div class="chat-header">
        <div class="back-btn" onclick="backToList()">
            <svg class="icon" viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg>
        </div>
        
        <div class="header-center">
            <div class="chat-title" id="currentChatTitle" onclick="openWhisperModal()">加载中...</div>
            <div class="chat-status" onclick="openStatusEdit()">
                <div class="status-dot"></div>
                <span id="headerStatusText">在线</span>
            </div>
        </div>

        <div class="chat-header-right">
            <div class="header-icon-btn" id="listenBtn" onclick="openListenModal()">
                <svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle><path d="M12 12 L12 2"></path></svg>
            </div>
            <div class="header-icon-btn" id="chatDetailBtn" onclick="goToCharDetail()">
                <svg class="icon" viewBox="0 0 24 24" style="stroke-width:2.5;"><line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line></svg>
            </div>
        </div>
    </div>

    <div class="chat-body" id="msgContainer"></div>

    <iframe id="funcFrame" class="func-frame-container"></iframe>
    
    <!-- 新增：表情面板 iframe -->
    <iframe id="emoticonFrame" class="emoticon-frame-container" src=""></iframe>

    <div class="input-bar-wrap">
        <button class="action-btn btn-plus" onclick="toggleFuncFrame()">
            <svg class="icon" viewBox="0 0 24 24" style="width:20px;height:20px;"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>

        <input type="text" class="input-field" id="msgInput" placeholder="发消息..." autocomplete="off">
        <button class="action-btn btn-reply" id="replyBtn" onclick="triggerAiReply()">
            <svg class="icon" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>
        </button>
        <button class="action-btn btn-send" onclick="sendUserMsg()">
            <svg class="icon" viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
    </div>

    <!-- 弹窗部分 -->
    <div class="modal-overlay" id="editMsgModal">
        <div class="modal-card">
            <div class="modal-title">编辑消息</div>
            <textarea 
                class="modal-input" 
                id="editMsgInput" 
                rows="1" 
                style="text-align: left; resize: none; overflow-y: auto; max-height: 300px; min-height: 40px;"
                oninput="this.style.height = 'auto'; this.style.height = (this.scrollHeight) + 'px';"
            ></textarea>
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('editMsgModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="confirmEditMsg()">确定</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay pat-glow" id="patModal">
        <div class="modal-card">
            <div class="modal-title">拍一拍</div>
            <div class="modal-msg">你拍了拍“<span id="patTargetName"></span>”...</div>
            <input type="text" class="modal-input" id="patSuffixInput" placeholder="请输入后缀 (选填)" maxlength="15">
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('patModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="sendPat()">确定</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="recallViewModal">
        <div class="modal-card">
            <div class="modal-title">撤回的消息</div>
            <div class="modal-msg" id="recallContentText" style="font-style: italic; color: #555; padding: 10px; background: #f9f9fc; border-radius: 10px;"></div>
            <div class="modal-btns">
                <button class="m-btn confirm full-width" onclick="document.getElementById('recallViewModal').style.display='none'">关闭</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="statusModal">
        <div class="modal-card">
            <div class="modal-title">修改状态</div>
            <input type="text" class="modal-input" id="statusInput" placeholder="例如：忙碌中..." maxlength="10">
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('statusModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="saveStatus()">保存</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay thoughts-glow" id="thoughtsModal">
        <div class="modal-card">
            <svg class="close-icon" onclick="document.getElementById('thoughtsModal').style.display='none'" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            <svg class="history-clock" onclick="toggleThoughtsHistory()" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
            <div class="modal-title" id="thoughtsTitle" style="margin-bottom:15px">角色心声</div>
            <div class="thoughts-container" id="currentThoughtsView">
                <div class="thought-section"><span class="thought-label">当前状态 (STATUS)</span><span class="thought-content" id="thoughtStatus">读取中...</span></div>
                <div class="thought-section"><span class="thought-label">今日穿搭 (OUTFIT)</span><span class="thought-content" id="thoughtOutfit">读取中...</span></div>
                <div class="thought-section"><span class="thought-label">此刻心声 (THOUGHTS)</span><span class="thought-content" id="thoughtMind">读取中...</span></div>
            </div>
            <div class="history-list-view" id="historyThoughtsView"></div>
        </div>
    </div>

    <div class="modal-overlay" id="errorModal">
        <div class="modal-card"><div class="modal-title" style="color:#FF3B30">提示</div><div class="modal-msg" id="errorMsgText"></div><button class="m-btn confirm full-width" onclick="document.getElementById('errorModal').style.display='none'">好的</button></div>
    </div>

    <!-- 1. 剧情推进输入弹窗 -->
    <div class="modal-overlay" id="advanceModal">
        <div class="modal-card">
            <div class="modal-title">剧情推进</div>
            <textarea class="modal-input" id="advanceInput" rows="3" placeholder="例如：刚才我们一起去看了电影..." style="text-align:left; resize:none;"></textarea>
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('advanceModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="confirmAdvance()">发送</button>
            </div>
        </div>
    </div>

    <!-- 2. 转账输入弹窗 -->
    <div class="modal-overlay" id="transferModal">
        <div class="modal-card">
            <div class="modal-title">转账</div>
            <input type="number" class="modal-input" id="transferAmount" placeholder="金额 (¥)" step="0.01">
            <input type="text" class="modal-input" id="transferNote" placeholder="备注 (选填)" style="margin-top:10px;">
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('transferModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="confirmTransfer()">转账</button>
            </div>
        </div>
    </div>

    <!-- 3. 语音输入弹窗 -->
    <div class="modal-overlay" id="voiceModal">
        <div class="modal-card">
            <div class="modal-title">发语音</div>
            <textarea class="modal-input" id="voiceTextInput" rows="3" placeholder="输入你想说的话 (将转换为语音条)" style="text-align:left; resize:none;"></textarea>
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('voiceModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="confirmVoice()">发送</button>
            </div>
        </div>
    </div>

    <!-- 4. 图片输入弹窗 -->
    <div class="modal-overlay" id="imageInputModal">
        <div class="modal-card">
            <div class="modal-title">发图片</div>
            <textarea class="modal-input" id="imageDescInput" rows="3" placeholder="描述图片内容..." style="text-align:left; resize:none;"></textarea>
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="document.getElementById('imageInputModal').style.display='none'">取消</button>
                <button class="m-btn confirm" onclick="confirmImage()">发送</button>
            </div>
        </div>
    </div>

    <!-- 5. 图片查看弹窗 (带粉色光晕) -->
    <div class="modal-overlay img-glow" id="imageViewModal">
        <div class="modal-card">
            <div class="modal-title" style="font-size:14px; color:#999;">图片内容</div>
            <div class="img-desc-text" id="imageViewText"></div>
            <button class="m-btn confirm full-width" onclick="document.getElementById('imageViewModal').style.display='none'">关闭</button>
        </div>
    </div>

    <!-- 6. 角色收到转账的处理弹窗 -->
    <div class="modal-overlay" id="charTransferActionModal">
        <div class="modal-card">
            <div class="modal-title">处理转账</div>
            <div class="modal-msg">角色要怎么处理这笔转账？</div>
            <div class="modal-btns">
                <button class="m-btn cancel" onclick="handleTransferAction('return')">退回</button>
                <button class="m-btn confirm" style="background:#FF6B81;" onclick="handleTransferAction('accept')">收取</button>
            </div>
        </div>
    </div>

    <!-- 7. 用户点击转账时的选择弹窗 (新增) -->
    <div class="modal-overlay" id="userReceiveTransferModal">
        <div class="modal-card">
            <div class="modal-title">转账确认</div>
            <div class="modal-msg">确认收取对方的转账吗？</div>
            <div class="modal-btns">
                <!-- 这里的 refuse 和 accept 会调用我们在第三步写的新函数 -->
                <button class="m-btn cancel" onclick="confirmUserTransferAction('returned')">拒收</button>
                <button class="m-btn confirm" style="background:#FF6B81;" onclick="confirmUserTransferAction('accepted')">收取</button>
            </div>
        </div>
    </div>

    <script>
        const DB_KEY = 'qq_app_data_pro_max_final';
        let characters = []; 
        let tempTransferIndex = -1; // 用来暂存当前点击的转账消息下标
        let activeChatId = null;
        let currentChar = null; // 当前聊天对象缓存
        const TIME_INTERVAL = 30 * 60 * 1000;
        const BEAR_SVG = `<svg viewBox="0 0 100 100" class="bear-svg"><circle cx="50" cy="50" r="50" fill="#f0f0f5"/><circle cx="20" cy="25" r="12" fill="#d1d1d6"/><circle cx="80" cy="25" r="12" fill="#d1d1d6"/><circle cx="50" cy="55" r="35" fill="#e5e5ea"/><circle cx="38" cy="50" r="4" fill="#8e8e93"/><circle cx="62" cy="50" r="4" fill="#8e8e93"/><ellipse cx="50" cy="65" rx="8" ry="6" fill="#fff"/><circle cx="50" cy="63" r="3" fill="#333"/></svg>`;

        let clickTimer = null;
        let longPressTimer = null;
        let selectedMsgIndex = -1;
        let quotingContent = null; 

        // --- 新增：钱包余额与记录更新函数 ---
function updateWalletBalance(changeAmount, reason) {
    const BALANCE_KEY = 'qq_money_balance';
    const HISTORY_KEY = 'qq_money_history'; // 新增的记录Key
    
    // 1. 更新余额
    let current = parseFloat(localStorage.getItem(BALANCE_KEY));
    if(isNaN(current)) current = 1314.52; // 如果没存过，给个默认值
    let newBalance = current + changeAmount;
    localStorage.setItem(BALANCE_KEY, newBalance.toFixed(2));

    // 2. 写入流水记录
    let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
    const now = new Date();
    // 格式化时间 mm-dd hh:mm
    const timeStr = `${(now.getMonth()+1).toString().padStart(2,'0')}-${now.getDate().toString().padStart(2,'0')} ${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`;
    
    history.unshift({
        amount: changeAmount, // 存带正负号的数值
        desc: reason,
        time: timeStr
    });
    
    // 只保留最近 50 条记录
    if(history.length > 50) history = history.slice(0, 50);
    localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
}

        function loadData() {
            const raw = localStorage.getItem(DB_KEY);
            if(raw) { characters = JSON.parse(raw); }
        }
        function saveData() { localStorage.setItem(DB_KEY, JSON.stringify(characters)); }
        function closeModal(id, e) { if(e.target.id === id) document.getElementById(id).style.display = 'none'; }
        
        function backToList() { window.location.href = 'qq.html'; }
        function goToCharDetail() { if(!activeChatId) return; localStorage.setItem('edit_char_id', activeChatId); window.location.href = 'char_detail.html'; }
        
        function openListenModal() { 
            const frame = document.getElementById('listenFrame');
            frame.classList.add('active');
            frame.contentWindow.postMessage({action: 'show'}, '*');
        }

        window.onload = function() {
            loadData();
            const urlParams = new URLSearchParams(window.location.search);
            activeChatId = urlParams.get('id');
            if(activeChatId) {
                renderChat(activeChatId);
                // 搜索跳转逻辑
                const jumpIdx = localStorage.getItem('chat_jump_index');
                if (jumpIdx !== null) {
                    localStorage.removeItem('chat_jump_index');
                    setTimeout(() => {
                        const rows = document.querySelectorAll('.msg-row');
                        if(rows[jumpIdx]) {
                            rows[jumpIdx].scrollIntoView({behavior: 'smooth', block: 'center'});
                            rows[jumpIdx].style.transition = 'background 1s';
                            rows[jumpIdx].style.backgroundColor = 'rgba(255, 235, 59, 0.3)';
                            setTimeout(() => rows[jumpIdx].style.backgroundColor = 'transparent', 2000);
                        }
                    }, 500);
                }
            } else {
                alert("未找到聊天对象");
                backToList();
            }
            
            window.addEventListener('message', function(event) {
                const data = event.data;
                if (!data) return;
                
                if (data.action === 'menuAction') {
                    menuAction(data.cmd);
                } else if (data.action === 'closeMenu') {
                    document.getElementById('menuFrame').classList.remove('active');
                } else if (data.action === 'closeListen') {
                    document.getElementById('listenFrame').classList.remove('active');
                    
                } 
                // --- 新增：表情包相关 ---
                else if (data.action === 'closeEmoticon') {
                    document.getElementById('emoticonFrame').classList.remove('active');
                }
                else if (data.action === 'sendEmoticon') {
                    // 用户点击了表情包
                    // data 结构: { url: '...', name: '...' }
                    document.getElementById('emoticonFrame').classList.remove('active');
                    appendSpecialMsg('emoticon', { url: data.url, name: data.name }, true);
                }
            });
        };

        // 处理来自 iframe 的指令
window.handleFuncAction = function(type) {
    if (type === 'regenerate') {
        handleRegenerate();
    } else if (type === 'emoticon') {
        // 打开表情面板
        const emoFrame = document.getElementById('emoticonFrame');
        if (!emoFrame.getAttribute('src')) { emoFrame.src = 'emoticon.html'; }
        emoFrame.classList.add('active');
        // 通知 emoticon.html 刷新可能的绑定数据或状态
        setTimeout(() => {
             emoFrame.contentWindow.postMessage({action: 'refresh'}, '*');
        }, 100);
    } else if (type === 'advance') {
        document.getElementById('advanceInput').value = '';
        document.getElementById('advanceModal').style.display = 'flex';
    } else if (type === 'transfer') {
        document.getElementById('transferAmount').value = '';
        document.getElementById('transferNote').value = '';
        document.getElementById('transferModal').style.display = 'flex';
    } else if (type === 'voice') {
        document.getElementById('voiceTextInput').value = '';
        document.getElementById('voiceModal').style.display = 'flex';
    } else if (type === 'image') {
        document.getElementById('imageDescInput').value = '';
        document.getElementById('imageInputModal').style.display = 'flex';
    }
};

// --- 1. 重说逻辑 ---
function handleRegenerate() {
    if (!currentChar || currentChar.history.length === 0) return;
    
    // 从后往前找，删除所有连续的 assistant 消息
    let hasDeleted = false;
    for (let i = currentChar.history.length - 1; i >= 0; i--) {
        if (currentChar.history[i].role === 'assistant') {
            currentChar.history.pop();
            hasDeleted = true;
        } else {
            break; // 遇到用户消息停止
        }
    }
    
    if (hasDeleted) {
        saveData();
        renderChat(activeChatId);
        // 重新触发回复
        triggerAiReply();
    } else {
        alert("上一条不是角色的回复，无法重说");
    }
}

// --- 2. 剧情推进 ---
function confirmAdvance() {
    const text = document.getElementById('advanceInput').value.trim();
    if (!text) return;
    
    document.getElementById('advanceModal').style.display = 'none';
    
    // 发送系统样式的剧情提示
    const sysMsg = `剧情推进：${text}`;
    currentChar.history.push({ role: 'system', content: sysMsg, timestamp: Date.now() });
    saveData();
    renderChat(activeChatId);
    
    // 触发 AI 读取
    triggerAiReply(); 
}

// --- 3. 转账 ---
function confirmTransfer() {
    const amount = document.getElementById('transferAmount').value;
    const note = document.getElementById('transferNote').value;
    if (!amount) return;

    document.getElementById('transferModal').style.display = 'none';

    updateWalletBalance(-parseFloat(amount), `给 ${currentChar.name} 转账`);
    
    // 发送转账消息 type: 'transfer'
    appendSpecialMsg('transfer', { amount: amount, note: note, status: 'pending' }, true);
}

// --- 4. 语音 ---
function confirmVoice() {
    const text = document.getElementById('voiceTextInput').value.trim();
    if (!text) return;

    document.getElementById('voiceModal').style.display = 'none';
    
    // 估算时长 (每3个字1秒，最少2秒)
    let duration = Math.max(2, Math.floor(text.length / 3)) + '"';
    
    appendSpecialMsg('voice', { text: text, duration: duration }, true);
}

// --- 5. 图片 ---
function confirmImage() {
    const desc = document.getElementById('imageDescInput').value.trim();
    if (!desc) return;

    document.getElementById('imageInputModal').style.display = 'none';
    appendSpecialMsg('image', { desc: desc }, true);
}

// --- 通用：发送特殊消息 ---
function appendSpecialMsg(type, data, isMe) {
    if (!currentChar) return;
    
    currentChar.history.push({
        role: isMe ? 'user' : 'assistant',
        msgType: type, // 标记特殊类型
        content: JSON.stringify(data), // 数据存为 JSON 字符串
        timestamp: Date.now()
    });
    saveData();
    renderChat(activeChatId);
}

        function toggleFuncFrame() {
            const frame = document.getElementById('funcFrame');
            if (!frame.getAttribute('src')) { frame.src = 'qq_func_panel.html'; }
            if (frame.classList.contains('active')) { frame.classList.remove('active'); } else { frame.classList.add('active'); }
        }
        window.closeFuncFrame = function() { document.getElementById('funcFrame').classList.remove('active'); }

        const msgContainer = document.getElementById('msgContainer');
        const msgInput = document.getElementById('msgInput');

        function renderChat(id) {
            const char = characters.find(c => c.id === id);
            if(!char) { backToList(); return; }
            currentChar = char; // 更新缓存

            // 应用详情页设定
            document.getElementById('currentChatTitle').innerText = char.name; // 显示备注名
            document.getElementById('headerStatusText').innerText = char.currentStatus || "在线";
            
            // 应用美化：背景
            if(char.chatBg) {
                document.body.style.backgroundImage = `url(${char.chatBg})`;
            } else {
                document.body.style.backgroundImage = 'none';
            }
            
            // --- 【修改开始】应用美化：气泡CSS + 全界面UI CSS ---
            let finalStyle = "";

            // 1. 处理气泡样式 (保持原有逻辑)
            if(char.bubbleCss) {
                if(char.bubbleCss.includes('{')) {
                    finalStyle += char.bubbleCss + "\n";
                } else {
                    finalStyle += `.bubble { ${char.bubbleCss} }\n`;
                }
            }

            // 2. 处理全界面UI样式 (新增逻辑)
            if(char.uiCss) {
                finalStyle += char.uiCss;
            }

            // 3. 统一注入
            document.getElementById('dynamicStyles').innerHTML = finalStyle;
            // --- 【修改结束】 ---

            const isChar = char.type === 'char';
            document.getElementById('chatDetailBtn').style.visibility = isChar ? 'visible' : 'hidden';
            document.getElementById('listenBtn').style.visibility = isChar ? 'visible' : 'hidden';

            msgContainer.innerHTML = '';
            
            if(!char.history) char.history = []; // 确保有历史数组
            
            let lastTime = 0;
            char.history.forEach((msg, index) => {
                const msgTime = msg.timestamp || 0;
                if (msgTime - lastTime > TIME_INTERVAL) {
                    appendTime(msgTime);
                    lastTime = msgTime;
                }

                if(msg.isRecall) {
                    const row = document.createElement('div');
                    row.className = 'msg-system-row';
                    if (msg.role === 'assistant') {
                        row.innerHTML = `<div class="sys-bubble">
                            ${char.name} 撤回了一条消息 <span class="sys-recall-link" onclick="viewRecalledContent('${msg.recalledContent.replace(/'/g, "\\'")}')" style="margin-left:5px; font-size:11px;">[点击查看]</span>
                        </div>`;
                    } else {
                        row.innerHTML = `<div class="sys-bubble">你撤回了一条消息</div>`;
                    }
                    msgContainer.appendChild(row);
                } else if(msg.role === 'system') {
                    const row = document.createElement('div'); 
                    row.className = 'msg-system-row';
                    row.innerHTML = `<div class="sys-bubble" oncontextmenu="return false;" ontouchstart="handleMsgTouchStart(event, ${index}, 'system')" ontouchend="handleMsgTouchEnd()">${msg.content}</div>`;
                    msgContainer.appendChild(row);
                } else {
                    appendBubble(msg.content, msg.role === 'user', index, false, msg.quoteData, msg.msgType || 'text');
                }
            });
            scrollToBottom();
            cancelQuote(); 
        }

        function appendTime(ts) {
            const date = new Date(ts);
            const now = new Date();
            const div = document.createElement('div'); 
            div.className = 'msg-time';

            const timeStr = `${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            const isToday = date.getDate() === now.getDate() && date.getMonth() === now.getMonth() && date.getFullYear() === now.getFullYear();
            const yesterday = new Date(now); yesterday.setDate(now.getDate() - 1);
            const isYesterday = date.getDate() === yesterday.getDate() && date.getMonth() === yesterday.getMonth() && date.getFullYear() === yesterday.getFullYear();
            const isThisYear = date.getFullYear() === now.getFullYear();

            if (isToday) div.innerText = timeStr;
            else if (isYesterday) div.innerText = `昨天 ${timeStr}`;
            else if (isThisYear) div.innerText = `${date.getMonth() + 1}月${date.getDate()}日 ${timeStr}`;
            else div.innerText = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日 ${timeStr}`;

            msgContainer.appendChild(div);
        }

        // 修改 appendBubble 支持特殊消息
function appendBubble(text, isMe, index, save = true, quoteData = null, msgType = 'text') {
    const row = document.createElement('div');
    row.className = `msg-row ${isMe ? 'me' : 'ai'}`;
    
    // 头像逻辑 (保持不变)
    let avatarSrc = BEAR_SVG; 
    let hasImg = false;
    if(isMe && currentChar && currentChar.userAvatar) {
        avatarSrc = `<img src="${currentChar.userAvatar}" class="msg-avatar-img">`; hasImg = true;
    } else if(!isMe && currentChar && currentChar.avatar) {
        avatarSrc = `<img src="${currentChar.avatar}" class="msg-avatar-img">`; hasImg = true;
    }
    const avatarBox = `<div class="msg-avatar-box" ${!isMe ? 'onclick="handleAvatarClick(event)"' : ''}>${avatarSrc}</div>`;
    
    let bubbleHtml = '';
    
    // --- 根据 msgType 渲染不同气泡 ---
    
    if (msgType === 'transfer') {
        // 解析 JSON 数据
        let data = {};
        try { data = JSON.parse(text); } catch(e) { data = { amount: '?', note: text }; } // 兼容旧文本
        
        let statusText = '';
        if (data.status === 'accepted') statusText = '已收款';
        else if (data.status === 'returned') statusText = '已退回';
        
        // 转账气泡结构
        const inner = `
            <div class="transfer-card">
                <div class="transfer-icon-circle">¥</div>
                <div class="transfer-info">
                    <div class="transfer-amount">¥${data.amount}</div>
                    ${data.note ? `<div class="transfer-desc">${data.note}</div>` : ''}
                </div>
            </div>
            ${statusText ? `<div class="transfer-status">${statusText}</div>` : ''}
        `;
        
        // 如果是AI发的转账，点击可以收款/退回
        // 如果是我的转账，且有状态，则显示状态
        // 这里添加点击事件，仅当我是接收方(role!=me) 且状态为pending时有效，或者我是发送方查看状态
        // 简化逻辑：所有转账都用 pink-bubble 样式
        // 长按菜单依旧保留
        bubbleHtml = `<div class="bubble pink-bubble" 
            ontouchstart="handleMsgTouchStart(event, ${index}, '${isMe?'user':'ai'}')" 
            ontouchend="handleMsgTouchEnd()"
            onclick="handleTransferClick(${index}, ${isMe})">
            ${inner}
        </div>`;

    } else if (msgType === 'voice') {
        let data = {};
        try { data = JSON.parse(text); } catch(e) { data = { text: text, duration: '2"' }; }

        const voiceInner = `
            <div class="voice-bubble" onclick="toggleVoiceText(this)">
                <svg class="voice-icon" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                <span class="voice-duration">${data.duration}</span>
            </div>
            <div class="voice-text-content">${data.text}</div>
        `;
        
        bubbleHtml = `<div class="bubble pink-bubble" ontouchstart="handleMsgTouchStart(event, ${index}, '${isMe?'user':'ai'}')" ontouchend="handleMsgTouchEnd()">${voiceInner}</div>`;

    } else if (msgType === 'image') {
        let data = {};
        try { data = JSON.parse(text); } catch(e) { data = { desc: text }; }

        const imgInner = `
            <div class="bear-img-placeholder">
                <div class="bear-svg-lg">${BEAR_SVG}</div>
            </div>
        `;
        // 点击查看描述
        bubbleHtml = `<div class="bubble img-bubble" 
            onclick="showImageDesc('${data.desc.replace(/'/g, "\\'")}')"
            ontouchstart="handleMsgTouchStart(event, ${index}, '${isMe?'user':'ai'}')" 
            ontouchend="handleMsgTouchEnd()">
            ${imgInner}
        </div>`;
    
    } else if (msgType === 'emoticon') {
        let data = {};
        try { data = JSON.parse(text); } catch(e) { data = { url: '', name: '表情' }; }

        const emoInner = `
            <img src="${data.url}" class="emo-img" onerror="this.src='https://via.placeholder.com/100x100?text=Error'">
        `;
        
        bubbleHtml = `<div class="bubble emo-bubble" 
            ontouchstart="handleMsgTouchStart(event, ${index}, '${isMe?'user':'ai'}')" 
            ontouchend="handleMsgTouchEnd()">
            ${emoInner}
        </div>`;

    } else {
        // 普通文本 (text)
        const cleanText = text.replace(/\n/g, '<br>');
        let innerHtml = '';
        if (quoteData) {
            innerHtml += `<div class="reply-block"><div class="reply-sender">${quoteData.sender}</div><div class="reply-text">${quoteData.text}</div></div>`;
        }
        innerHtml += cleanText;
        bubbleHtml = `<div class="bubble" ontouchstart="handleMsgTouchStart(event, ${index}, '${isMe?'user':'ai'}')" ontouchend="handleMsgTouchEnd()">${innerHtml}</div>`;
    }
    
    row.innerHTML = avatarBox + bubbleHtml;
    msgContainer.appendChild(row);
    scrollToBottom();

    if(save && currentChar) {
        // 注意：如果是特殊消息，appendSpecialMsg 已经存过了，这里通常是手动发普通消息才 save=true
        // 为兼容原有逻辑，如果是普通文本且 save=true，则保存
        if (msgType === 'text') {
            currentChar.history.push({ 
                role: isMe ? 'user' : 'assistant', 
                content: text, 
                timestamp: Date.now(),
                quoteData: quoteData
            });
            saveData();
            scrollToBottom();
        }
    }
}

        function scrollToBottom() { setTimeout(() => { msgContainer.scrollTop = msgContainer.scrollHeight; }, 10); }

        function openStatusEdit() {
            const current = currentChar.currentStatus || "在线";
            document.getElementById('statusInput').value = current;
            document.getElementById('statusModal').style.display = 'flex';
        }
        function saveStatus() {
            const newVal = document.getElementById('statusInput').value.trim();
            if (newVal) {
                currentChar.currentStatus = newVal;
                saveData();
                renderChat(activeChatId);
            }
            document.getElementById('statusModal').style.display = 'none';
        }
        function viewRecalledContent(content) {
            document.getElementById('recallContentText').innerText = content;
            document.getElementById('recallViewModal').style.display = 'flex';
        }

        function handleAvatarClick(e) {
            e.stopPropagation();
            if (clickTimer) { clearTimeout(clickTimer); clickTimer = null; openThoughtsModal(); } 
            else { clickTimer = setTimeout(() => { openPatModal(); clickTimer = null; }, 300); }
        }
        function handleMsgTouchStart(e, index, type) { longPressTimer = setTimeout(() => { showContextMenu(e, index, type); }, 600); }
        function handleMsgTouchEnd() { if(longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } }
        
        function showContextMenu(e, index, type) {
            if(navigator.vibrate) navigator.vibrate(50);
            selectedMsgIndex = index;
            const touch = e.touches ? e.touches[0] : e;
            const menuFrame = document.getElementById('menuFrame');
            menuFrame.classList.add('active');
            menuFrame.contentWindow.postMessage({
                action: 'open',
                x: touch.clientX,
                y: touch.clientY,
                screenW: window.innerWidth,
                screenH: window.innerHeight
            }, '*');
        }

        function menuAction(action) {
            document.getElementById('menuFrame').classList.remove('active');
            if(!currentChar || selectedMsgIndex === -1) return;
            const msg = currentChar.history[selectedMsgIndex];

            if(action === 'copy') { navigator.clipboard.writeText(msg.content); }
            else if(action === 'edit') { 
                const editInput = document.getElementById('editMsgInput');
                editInput.value = msg.content; 
                document.getElementById('editMsgModal').style.display = 'flex'; 
                
                // --- 新增：打开时自动调整高度 ---
                // 先重置高度，再根据内容计算
                editInput.style.height = 'auto';
                editInput.style.height = (editInput.scrollHeight) + 'px';
                // 让光标自动聚焦
                setTimeout(() => editInput.focus(), 50);
            }
            else if(action === 'recall') { handleRecall(currentChar, selectedMsgIndex, msg); }
            else if(action === 'quote') {
                const senderName = (msg.role === 'user') ? '我' : currentChar.name;
                quotingContent = { sender: senderName, text: msg.content };
                document.getElementById('quoteText').innerText = `引用 ${senderName}: ${msg.content}`;
                document.getElementById('quoteBar').style.display = 'flex';
            }
        }

        function confirmEditMsg() {
            // 获取值，保留换行符，但去掉首尾空格
            const newVal = document.getElementById('editMsgInput').value.trim();
            if(newVal && currentChar && selectedMsgIndex !== -1) {
                currentChar.history[selectedMsgIndex].content = newVal;
                saveData(); 
                renderChat(activeChatId);
            }
            document.getElementById('editMsgModal').style.display = 'none';
        }

        function handleRecall(char, index, msg) {
            char.history[index] = { role: msg.role, content: '消息已撤回', timestamp: msg.timestamp, isRecall: true, recalledContent: msg.content };
            saveData(); renderChat(activeChatId);
        }

        function cancelQuote() { quotingContent = null; document.getElementById('quoteBar').style.display = 'none'; }

        function openPatModal() {
            if(!currentChar) return;
            document.getElementById('patTargetName').innerText = currentChar.name;
            document.getElementById('patSuffixInput').value = "";
            document.getElementById('patModal').style.display = 'flex';
            setTimeout(()=>document.getElementById('patSuffixInput').focus(), 100);
        }
        
        function sendPat(isFromAI = false, suffix = "") {
            if(!currentChar) return;
            let text = "";
            if (isFromAI) {
                // 修改点：强制显示用户昵称
                // 获取用户昵称，如果没有则默认为"你"
                const targetName = currentChar.userNickName || "你";
                
                // 如果后缀为空，只是"拍了拍XXX"
                if (!suffix) {
                    text = `${currentChar.name} 拍了拍 “${targetName}”`;
                } else {
                    // 如果有后缀，处理一下格式，变成 "角色名 拍了拍 “用户昵称” 后缀"
                    // 去掉后缀可能自带的"拍了拍"字样，避免重复
                    let cleanSuffix = suffix.replace(/^拍了拍/, '').trim();
                    text = `${currentChar.name} 拍了拍 “${targetName}” ${cleanSuffix}`;
                }
            } else {
                const inputSuffix = document.getElementById('patSuffixInput').value.trim();
                text = `我拍了拍“${currentChar.name}”${inputSuffix}`;
                document.getElementById('patModal').style.display = 'none';
            }
            currentChar.history.push({ role: 'system', content: text, timestamp: Date.now() });
            saveData(); 
            renderChat(activeChatId);
        }

        function aiPerformRecall() {
            if(!currentChar || currentChar.history.length === 0) return;
            let lastAiMsgIndex = -1;
            for (let i = currentChar.history.length - 1; i >= 0; i--) {
                if (currentChar.history[i].role === 'assistant' && !currentChar.history[i].isRecall) {
                    lastAiMsgIndex = i;
                    break;
                }
            }
            if (lastAiMsgIndex !== -1) { handleRecall(currentChar, lastAiMsgIndex, currentChar.history[lastAiMsgIndex]); }
        }

        function aiChangeStatus(newStatus) {
            if(!currentChar || !newStatus) return;
            currentChar.currentStatus = newStatus;
            saveData(); renderChat(activeChatId);
        }

        function openThoughtsModal() {
            if(!currentChar) return;
            document.getElementById('currentThoughtsView').classList.remove('hidden');
            document.getElementById('historyThoughtsView').classList.remove('active');
            const latest = (currentChar.thoughtsHistory && currentChar.thoughtsHistory.length > 0) ? currentChar.thoughtsHistory[currentChar.thoughtsHistory.length - 1] : { status: "发呆中", outfit: "便服", mind: "..." };
            document.getElementById('thoughtStatus').innerText = latest.status;
            document.getElementById('thoughtOutfit').innerText = latest.outfit;
            document.getElementById('thoughtMind').innerText = latest.mind;
            document.getElementById('thoughtsModal').style.display = 'flex';
        }

        function toggleThoughtsHistory() {
            if(!currentChar) return;
            const currentView = document.getElementById('currentThoughtsView');
            const historyView = document.getElementById('historyThoughtsView');
            if (historyView.classList.contains('active')) {
                historyView.classList.remove('active'); currentView.classList.remove('hidden');
            } else {
                currentView.classList.add('hidden'); historyView.classList.add('active');
                historyView.innerHTML = '';
                const list = currentChar.thoughtsHistory || [];
                [...list].reverse().forEach(t => {
                    const item = document.createElement('div'); item.className = 'history-item';
                    const timeStr = new Date(t.timestamp).toLocaleString();
                    item.innerHTML = `<div class="h-time">${timeStr}</div><div class="h-content"><b>状态:</b> ${t.status}</div><div class="h-content"><b>穿搭:</b> ${t.outfit}</div><div class="h-content" style="color:#007AFF">"${t.mind}"</div>`;
                    historyView.appendChild(item);
                });
            }
        }

        function sendUserMsg() {
            let text = msgInput.value.trim();
            if(!text) return;
            if(currentChar) {
                const lastMsg = currentChar.history[currentChar.history.length - 1];
                const lastTime = lastMsg ? (lastMsg.timestamp || 0) : 0;
                if (Date.now() - lastTime > TIME_INTERVAL) { appendTime(Date.now()); }
                // 传正确的index
                appendBubble(text, true, currentChar.history.length, true, quotingContent);
            }
            cancelQuote(); 
            msgInput.value = '';
        }

        async function triggerAiReply() {
            if(!currentChar) return;
            const rawPresets = localStorage.getItem('aiPhone_presets');
            const currentId = localStorage.getItem('aiPhone_currentId');
            let config = null;
            if (rawPresets && currentId) { try { config = JSON.parse(rawPresets).find(p => p.id == currentId); } catch(e) {} }
            if(!config || !config.url || !config.key) {
                document.getElementById('errorMsgText').innerText = "API 未连接"; document.getElementById('errorModal').style.display = 'flex'; return;
            }

            const originalName = document.getElementById('currentChatTitle').innerText;
            document.getElementById('currentChatTitle').innerText = "对方正在输入...";
            document.getElementById('currentChatTitle').classList.add('typing');
            document.getElementById('replyBtn').disabled = true;

            let fetchUrl = config.url.endsWith('/') ? config.url + 'v1/chat/completions' : config.url + '/v1/chat/completions';
            
            // --- 1. 构建 Prompt ---
            let sysContent = `角色扮演指令：\n`;
            // 昵称逻辑：这里明确告诉AI，它对用户的称呼是 userNickName
            sysContent += `你的真名: ${currentChar.trueName || currentChar.name}。\n`;

            // ==================== 【这里是新加的状态感知代码 开始】 ====================
            // 读取用户档案
            const userProfile = JSON.parse(localStorage.getItem('qq_user_profile') || '{"status":"在线","id":"Buzzy520"}');
            const currentUserStatus = userProfile.status || '在线';
            const userDisplayId = userProfile.id || 'Buzzy520';

            // 状态变更检测逻辑
            // 如果 lastReactedUserStatus 不存在，说明是第一次聊，或者之前没记录过，初始化为空
            if (typeof currentChar.lastReactedUserStatus === 'undefined') {
                currentChar.lastReactedUserStatus = ''; 
            }

            // 对比当前状态和上次反应过的状态
            if (currentUserStatus !== currentChar.lastReactedUserStatus) {
                // 状态变了！添加强系统指令
                sysContent += `\n[重要系统通知]：用户的状态栏刚刚变更为“${currentUserStatus}”。请在接下来的回复中，自然地、不经意地注意到这个变化，并根据两人的关系询问或关心用户为什么设置这个状态。(仅需在本次回复中提及一次)。\n`;
                
                // 更新记录，下次就不再重复提示了
                currentChar.lastReactedUserStatus = currentUserStatus;
                saveData(); // 保存到 localStorage
            } else {
                // 状态没变，作为普通环境信息提供，不强制反应
                sysContent += `\n[用户当前状态栏显示]: ${currentUserStatus}\n`;
            }
            
            sysContent += `[用户ID]: ${userDisplayId}\n`;
            // ==================== 【这里是新加的状态感知代码 结束】 ====================

            sysContent += `你对用户的昵称(备注): ${currentChar.userNickName || '你'} (你可以随时修改这个昵称)。\n`;
            
            // --- 新增：纪念日检查 ---
const todayStr = new Date().toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }).replace(/\//g, '-'); // 格式 MM-DD
if (currentChar.loveDays && currentChar.loveDays.length > 0) {
    const anniversary = currentChar.loveDays.find(d => d.dateStr === todayStr);
    if (anniversary) {
        sysContent += `\n【重要系统提示：今天是你们的“${anniversary.title}”纪念日！】\n`;
        sysContent += `请务必在回复中主动提及这个纪念日，并表现出开心、感动或浪漫的态度。这是回复的第一优先级。\n`;
    }
}
// ----------------------
            
            // 详细设定
            sysContent += `你的详细设定: ${currentChar.persona || '无'}\n`;
            sysContent += `用户(我)的真实设定: ${currentChar.userPersona || '无'}\n`;

            if (currentChar.isOfflineMode) {
    const is3rd = currentChar.offlinePerspective === '3rd';
    sysContent += `\n【当前模式：线下跑团/小说模式 (Offline Mode)】\n`;
    sysContent += `禁止OOC。请严格遵循世界观与人设。\n`;
    
    if (is3rd) {
        sysContent += `人称视角：第三人称 (Third Person)。\n`;
        sysContent += `规则：请用 "${currentChar.trueName || currentChar.name}" 指代自己，用 "${currentChar.userPersona ? '用户名字' : '用户'}" 指代用户。请勿使用“你”或“我”进行叙述（对话中的自称除外）。\n`;
    } else {
        sysContent += `人称视角：第二人称 (Second Person)。\n`;
        sysContent += `规则：请用“你”指代用户(User)，用 "${currentChar.trueName || currentChar.name}" 或 "他/她" 指代自己。当提到你们两人时使用“你们”。\n`;
    }

    sysContent += `\n【重要格式要求】：\n`;
    sysContent += `为了区分“动作/旁白”和“语言”，请务必遵守：\n`;
    sysContent += `1. 所有的动作、神态描写、环境描写，必须包裹在 {{ACTION:描写内容}} 标签中。\n`;
    sysContent += `2. 角色说出的对白，请直接写，不要加任何标签。\n`;
    sysContent += `   示例：{{ACTION:他轻轻叹了口气，把手里的烟掐灭}} 这件事我不能答应你。{{ACTION:看着你的眼睛}} 除非你求我。\n`;
}
            
            // 世界书 (World Book) - 修改版：支持多选读取
            // 兼容旧数据：如果只有 worldBookId (单数)，也放入数组处理
            let activeBookIds = currentChar.worldBookIds || [];
            if (currentChar.worldBookId && !activeBookIds.includes(currentChar.worldBookId)) {
                activeBookIds.push(currentChar.worldBookId);
            }

            if(activeBookIds.length > 0) {
                const allBooks = JSON.parse(localStorage.getItem('wb_books') || '[]');
                
                // 遍历所有选中的世界书ID
                activeBookIds.forEach(bId => {
                    const book = allBooks.find(b => b.id == bId);
                    if(book) {
                        const activeEntries = book.entries.filter(e => e.active); // 只取启用的词条
                        if(activeEntries.length > 0) {
                            sysContent += `\n【世界观词条 (${book.name})】\n`;
                            activeEntries.forEach(e => {
                                // 必须读取到：将所有启用词条加入 Prompt
                                sysContent += `- [${e.name}]: ${e.content}\n`;
                            });
                        }
                    }
                });
            }

            // 环境感知 (修正时间逻辑：严格按时区)
            if(currentChar.timeSense) {
                let timeStr = new Date().toLocaleString(); // 默认系统
                if (currentChar.timeZoneValue) {
                    try {
                        timeStr = new Date().toLocaleString("zh-CN", {timeZone: currentChar.timeZoneValue});
                    } catch(e) {
                        console.error("Timezone error", e);
                    }
                }
                sysContent += `[当前系统时间(严格): ${timeStr}]\n`; 
                // 去掉了旧的 timeLocation 文本逻辑，完全依赖时区
            }

            // 环境感知 (修正天气逻辑：真实地名映射)
            if(currentChar.weatherSense) {
                const charReal = currentChar.charWeatherRealLoc || "";
                const charVirtual = currentChar.charWeatherVirtualLoc || "此处";
                
                // 新增：读取用户虚拟名
                const userReal = currentChar.userWeatherRealLoc || "";
                const userVirtual = currentChar.userWeatherVirtualLoc || userReal || "你那边"; // 如果没填虚拟名，回落到真实名或通用词

                sysContent += `[环境/天气感知]:\n`;
                
                // 角色部分
                if(charReal) {
                    sysContent += `- 你的位置: 设定在 "${charVirtual}" (真实物理坐标参考: "${charReal}")。请根据真实坐标的经纬度/气候/时令来描写环境。\n`;
                }
                
                // 用户部分 (修改了这里)
                if(userReal) {
                    sysContent += `- 用户的位置: 设定在 "${userVirtual}" (真实物理坐标参考: "${userReal}")。\n`;
                }
                
                sysContent += `- 注意: 请严格基于上述"真实物理坐标"的客观时间与气候进行感知，但对话中请使用"设定位置"的地名。\n`;
            }

            // 记忆库
            if(currentChar.longTermMemories && currentChar.longTermMemories.length > 0) {
                sysContent += `\n【长期记忆】\n`;
                currentChar.longTermMemories.forEach((m, i) => sysContent += `${i+1}. ${m}\n`);
            }

            // 回复规则 (增加了特殊消息格式说明)
            sysContent += `\n【核心规则】
            1. 拟人化: 分段发送，用 ||| 分隔。
            2. 口语化: 自然简短。
            3. 功能指令:
               - 拍一拍: {{PAT:后缀}}
               - 撤回: {{RECALL}}
               - 改状态: {{STATUS:新状态}}
               - 改用户昵称: {{NICKNAME:新昵称}}
               - 引用: {{QUOTE:内容}}
            
            【特殊功能格式 (Strict Format)】
            1. 发语音: {{SEND_VOICE:语音文字内容}}
            2. 发图片: {{SEND_IMAGE:图片画面详细描述}}
            3. 发转账: {{SEND_TRANSFER:金额:备注}} (例如 {{SEND_TRANSFER:520:拿去买糖}})
            4. 处理用户转账:
               - 如果你想收下用户的转账，输出: {{ACCEPT_TRANSFER}}
               - 如果你想退回用户的转账，输出: {{RETURN_TRANSFER}}
            
            [注意] 当收到系统消息提示“用户向你转账”时，请务必使用上述第4点指令进行处理。
            `;

            // --- 新增：读取并注入表情包信息 ---
            const allEmoticonData = JSON.parse(localStorage.getItem('qq_emoticon_db') || '{"categories":[],"bindings":{}}');
            // 获取绑定给当前角色ID的分类ID列表
            const boundCatIds = allEmoticonData.bindings[currentChar.id] || [];
            
            let availableEmoticons = [];
            // 遍历所有分类，如果在绑定列表中，则收集该分类下的表情名
            allEmoticonData.categories.forEach(cat => {
                if (boundCatIds.includes(cat.id) && cat.items.length > 0) {
                    // 为了防止Prompt过长，每个分类最多取前10个表情名作为示例，或者取全部
                    // 这里我们只取名字，告诉AI它有什么库存
                    cat.items.forEach(item => availableEmoticons.push(item.name));
                }
            });

            // 只有当有绑定表情包时，才写入 Prompt
            if (availableEmoticons.length > 0) {
                // 去重
                availableEmoticons = [...new Set(availableEmoticons)];
                // 限制数量，防止 Token 爆炸 (例如随机选 30 个给它，或者全部如果不多)
                const emoListStr = availableEmoticons.slice(0, 50).join(', ');
                
                sysContent += `\n【表情包系统】\n`;
                sysContent += `你可以发送表情包。你拥有的表情包列表: [${emoListStr}] 等。\n`;
                sysContent += `如果要发送表情包，请严格只输出指令: {{SEND_EMOTICON:表情包名字}}\n`;
                sysContent += `请根据当前氛围、对话内容，适度、生动地使用表情包，不要滥用。\n`;
            }
            
            // 历史记录处理 (上下文限制)
            const limit = currentChar.shortMemCount || 20;
            const rawHistory = currentChar.history.slice(-limit);
            const messages = [{ role: "system", content: sysContent }];
            
            rawHistory.forEach(msg => {
                let contentToSend = msg.content;
                
                // --- 特殊处理：如果用户或角色发送了表情包，转换成文字描述给 AI ---
                if (msg.msgType === 'emoticon') {
                    try {
                        const emoData = JSON.parse(msg.content);
                        contentToSend = `[发送了表情包: "${emoData.name}"]`;
                    } catch(e) {}
                }
                // 同理处理图片 (可选)
                else if (msg.msgType === 'image') {
                    contentToSend = `[发送了一张图片]`; 
                }
                // 处理转账
                else if (msg.msgType === 'transfer') {
                     try {
                        const tData = JSON.parse(msg.content);
                        contentToSend = `[发起转账: ${tData.amount}元, 备注: ${tData.note}]`;
                    } catch(e) {}
                }

                if(msg.isRecall) {
                    messages.push({ role: 'system', content: `[系统: ${msg.role==='user'?'用户':'你'} 撤回了一条消息]` });
                } else if(msg.role === 'system') {
                    messages.push({ role: 'system', content: `[系统消息: ${msg.content}]` });
                } else {
                    messages.push({ role: msg.role, content: contentToSend });
                }
            });

            try {
                const response = await fetch(fetchUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.key}` },
                    body: JSON.stringify({ model: config.model || 'gpt-3.5-turbo', messages: messages, temperature: 0.7, presence_penalty: 0.3 })
                });

                document.getElementById('currentChatTitle').classList.remove('typing');
                document.getElementById('currentChatTitle').innerText = originalName;
                document.getElementById('replyBtn').disabled = false;

                if (!response.ok) throw new Error("API Error");
                const data = await response.json();
                
                if (data.choices && data.choices.length > 0) {
                    const text = data.choices[0].message.content.trim();
                    parseAndExecuteAiResponse(text, config, messages);
                    // 自动总结
                    checkAutoSummary(config);
                }
            } catch (err) {
                document.getElementById('currentChatTitle').classList.remove('typing');
                document.getElementById('currentChatTitle').innerText = originalName;
                document.getElementById('replyBtn').disabled = false;
                document.getElementById('errorMsgText').innerText = "连接中断"; document.getElementById('errorModal').style.display = 'flex';
            }
        }

        function parseAndExecuteAiResponse(text, config, context) {
            // 1. 解析 NICKNAME
            const nickMatch = text.match(/{{NICKNAME:(.*?)}}/);
            if (nickMatch) {
                const newNick = nickMatch[1];
                currentChar.userNickName = newNick; 
                saveData(); 
                currentChar.history.push({role:'system', content:`${currentChar.name} 将你的备注修改为 "${newNick}"`, timestamp: Date.now()});
                renderChat(activeChatId); 
                text = text.replace(nickMatch[0], '');
            }

            // 2. 解析 基础指令
            if (text.includes('{{RECALL}}')) { aiPerformRecall(); text = text.replace('{{RECALL}}', ''); }
            const statusMatch = text.match(/{{STATUS:(.*?)}}/);
            if (statusMatch) { aiChangeStatus(statusMatch[1]); text = text.replace(statusMatch[0], ''); }
            const patMatch = text.match(/{{PAT:(.*?)}}/);
            if (patMatch) { sendPat(true, patMatch[1]); text = text.replace(patMatch[0], ''); }

            // 3. 解析 语音 {{SEND_VOICE:内容}}
            const voiceMatch = text.match(/{{SEND_VOICE:(.*?)}}/);
            if (voiceMatch) {
                let content = voiceMatch[1];
                let duration = Math.max(2, Math.floor(content.length / 3)) + '"';
                appendSpecialMsg('voice', { text: content, duration: duration }, false); // false = AI发的
                text = text.replace(voiceMatch[0], '');
            }

            // 4. 解析 图片 {{SEND_IMAGE:描述}}
            const imgMatch = text.match(/{{SEND_IMAGE:(.*?)}}/);
            if (imgMatch) {
                appendSpecialMsg('image', { desc: imgMatch[1] }, false);
                text = text.replace(imgMatch[0], '');
            }

            // 5.5 解析 表情包 {{SEND_EMOTICON:名字}}
            const emoMatch = text.match(/{{SEND_EMOTICON:(.*?)}}/);
            if (emoMatch) {
                const targetName = emoMatch[1].trim();
                // 去数据库找对应的 URL
                const allEmoDB = JSON.parse(localStorage.getItem('qq_emoticon_db') || '{"categories":[],"bindings":{}}');
                let foundUrl = null;
                
                // 简单的查找逻辑：遍历所有分类找名字匹配的
                // 也可以限制只在绑定的分类里找，这里为了容错，全库查找
                for (const cat of allEmoDB.categories) {
                    const foundItem = cat.items.find(item => item.name === targetName);
                    if (foundItem) {
                        foundUrl = foundItem.url;
                        break;
                    }
                }
                
                if (foundUrl) {
                    appendSpecialMsg('emoticon', { url: foundUrl, name: targetName }, false);
                }
                text = text.replace(emoMatch[0], '');
            }

            // 5. 解析 发起转账 {{SEND_TRANSFER:金额:备注}}
            const transferMatch = text.match(/{{SEND_TRANSFER:([\d\.]+):?(.*?)}}/);
            if (transferMatch) {
                let amount = transferMatch[1];
                let note = transferMatch[2] || '';
                appendSpecialMsg('transfer', { amount: amount, note: note, status: 'pending' }, false);
                text = text.replace(transferMatch[0], '');
            }

            // 6. 解析 处理转账 (接收/退回)
            if (text.includes('{{ACCEPT_TRANSFER}}')) {
                aiProcessTransfer('accepted');
                text = text.replace('{{ACCEPT_TRANSFER}}', '');
            }
            if (text.includes('{{RETURN_TRANSFER}}')) {
                aiProcessTransfer('returned');
                text = text.replace('{{RETURN_TRANSFER}}', '');
            }

            // =========================
            // 这里是【线下模式】的新增逻辑
            // =========================
            if (currentChar.isOfflineMode && text.includes('{{ACTION:')) {
                // 如果开启了线下模式，且AI返回了动作标签，我们使用新的拆分逻辑
                const parts = text.split(/({{ACTION:.*?}})/g).filter(p => p.trim());
                
                let sequencePromise = Promise.resolve();

                parts.forEach(part => {
                    sequencePromise = sequencePromise.then(async () => {
                        const actionMatch = part.match(/{{ACTION:(.*?)}}/);
                        
                        if (actionMatch) {
                            // --- 情况A：这是动作 (生成灰色系统气泡) ---
                            const actionContent = actionMatch[1].trim();
                            if (actionContent) {
                                currentChar.history.push({
                                    role: 'system',
                                    content: actionContent, // 动作内容
                                    timestamp: Date.now()
                                });
                                saveData();
                                renderChat(activeChatId);
                                // 暂停 0.6秒，增加阅读节奏感
                                await new Promise(r => setTimeout(r, 600));
                            }
                        } else {
                            // --- 情况B：这是对话 (生成白色聊天气泡) ---
                            // 对话依然支持 ||| 分段
                            const subParts = part.split(/\|\|\||\n/).map(p => p.trim()).filter(p => p);
                            for (let sub of subParts) {
                                currentChar.history.push({
                                    role: 'assistant',
                                    content: sub,
                                    timestamp: Date.now()
                                });
                                saveData();
                                renderChat(activeChatId);
                                // 模拟打字速度延迟
                                await new Promise(r => setTimeout(r, 800 + sub.length * 50));
                            }
                        }
                    });
                });

                // 全部播放完毕后，生成心声
                sequencePromise.then(() => {
                     generateThoughts(config, context, text); 
                });

                // *** 重要：直接返回，不再执行下面的旧逻辑 ***
                return; 
            }
            // =========================
            // 新增逻辑结束
            // =========================

            // 下面是原本的逻辑（如果没有开启线下模式，或者没有动作标签，就走这里）
            let parts = text.split(/\|\|\||\n/).map(p => p.trim()).filter(p => p);
            
            if (parts.length > 0) {
                if(Date.now() - (currentChar.history[currentChar.history.length-1].timestamp||0) > TIME_INTERVAL) appendTime(Date.now());
                
                let i = 0;
               function playNext() {
                    if (i < parts.length && activeChatId === currentChar.id) {
                        let partText = parts[i];
                        let quoteData = null;
                        const quoteMatch = partText.match(/{{QUOTE:(.*?)}}/);
                        if (quoteMatch) {
                            quoteData = { sender: '我', text: quoteMatch[1] }; 
                            partText = partText.replace(quoteMatch[0], '').trim();
                        }
                        if (partText) {
                            // 最后一个参数传 'text'，因为特殊消息已经在上面处理完了
                            appendBubble(partText, false, currentChar.history.length, true, quoteData, 'text');
                        }
                        i++;
                        let delay = 800 + (partText.length * 50) + Math.random() * 500;
                        if (i < parts.length) setTimeout(playNext, delay);
                        else generateThoughts(config, context, text); 
                    }
                }
                playNext();
            } else {
                generateThoughts(config, context, "(动作/功能执行)");
            }
        }

        /* --- 修改位置 2：心声与悄悄话生成逻辑 (100%触发心声，80%触发悄悄话) --- */
async function generateThoughts(config, context, lastReply) {
    // 1. 独立概率判断：是否触发悄悄话 (80% 概率)
    // 注意：这里只决定“要不要让AI写悄悄话”，不影响“心声”的生成
    const triggerWhisper = Math.random() < 0.8; 

    console.log(`[生成系统] 心声: 100% | 悄悄话触发: ${triggerWhisper}`);

    const fetchUrl = config.url.endsWith('/') ? config.url + 'v1/chat/completions' : config.url + '/v1/chat/completions';
    
    // 2. 构建 Prompt：必须包含心声，选择性包含悄悄话
    // 我们将所有指令合并在一个 Prompt 里，让 AI 一次性返回 JSON，避免多次请求导致回复敷衍或变慢
    let prompt = `任务：请根据刚才的对话内容，分析角色当前的内心状态。
    
    【必须生成的内容 (100%)】
    请更新角色的以下三项状态：
    1. status: 当前的状态，以及看到消息的反应，严格遵循角色设定，不可OOC。
    2. outfit: 今天的穿搭描述，不得简述，严格按照角色设定以及当前状态搭配穿搭。
    3. mind: 此刻内心没说出口的真实想法 (第一人称)，必须完全符合角色设定和当前聊天内容，严禁OOC，50字左右。
    `;

    if (triggerWhisper) {
        prompt += `
    【额外生成的内容】
    你现在的表达欲很强，请额外写一张【悄悄话便签】给用户。
    规则：
    1. 必须用“我”自称，称呼用户为“你”。
    2. 内容是想对用户说但没发在聊天框里的私房话，或者一种情绪的补充。
    3. 风格要生动可爱，1-3句话。
        `;
    }

    prompt += `
    【最终格式要求】
    请务必只返回一段合法的 JSON 代码，不要包含 markdown 标记或额外文字。格式如下：
    {
        "status": "...",
        "outfit": "...",
        "mind": "..."${triggerWhisper ? ',\n        "whisper_content": "这里填悄悄话内容"' : ''}
    }`;

    try {
        const res = await fetch(fetchUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.key}` },
            body: JSON.stringify({ 
                model: config.model || 'gpt-3.5-turbo', 
                // 只取最近的上下文，减少 token 消耗，保证速度
                messages: [
                    ...context.slice(-6), 
                    {role: 'assistant', content: lastReply}, 
                    {role: 'system', content: prompt}
                ], 
                temperature: 0.8 // 稍微高一点的创造性
            })
        });

        if(res.ok) {
            const data = await res.json();
            let content = data.choices[0].message.content;
            
            // 清理可能存在的 markdown 代码块标记 (```json ... ```)
            content = content.replace(/```json/g, '').replace(/```/g, '').trim();

            const jsonStart = content.indexOf('{');
            const jsonEnd = content.lastIndexOf('}');
            
            if(jsonStart !== -1 && jsonEnd !== -1) {
                const result = JSON.parse(content.substring(jsonStart, jsonEnd+1));
                
                // --- 逻辑 A: 100% 处理心声 (修复之前心声坏了的问题) ---
                if (result.status || result.mind) {
                    const newThought = {
                        status: result.status || "在线",
                        outfit: result.outfit || "日常",
                        mind: result.mind || "...",
                        timestamp: Date.now()
                    };
                    
                    if (!currentChar.thoughtsHistory) currentChar.thoughtsHistory = [];
                    currentChar.thoughtsHistory.push(newThought);
                    // 限制历史记录数量，防爆
                    if (currentChar.thoughtsHistory.length > 50) currentChar.thoughtsHistory.shift();
                    
                    console.log("心声已更新:", newThought);
                }

                // --- 逻辑 B: 如果生成了悄悄话，则保存 (80% 触发) ---
                if (triggerWhisper && result.whisper_content) {
                    const newNote = {
                        id: Date.now(),
                        text: result.whisper_content,
                        // 随机样式
                        bgStyle: ['note-style-hearts', 'note-style-dots', 'note-style-grid', 'note-style-cloud'][Math.floor(Math.random() * 4)],
                        rotateClass: ['rotate-left', 'rotate-right', 'rotate-big-left', 'rotate-big-right'][Math.floor(Math.random() * 4)],
                        textStyle: ['normal', 'text-bold-pink', 'text-small', 'text-messy'][Math.floor(Math.random() * 4)],
                        specialEffect: Math.random() < 0.1 ? 'text-bounce' : (Math.random() < 0.1 ? 'text-strike' : '')
                    };

                    if(!currentChar.whisperNotes) currentChar.whisperNotes = [];
                    currentChar.whisperNotes.unshift(newNote);
                    if(currentChar.whisperNotes.length > 20) currentChar.whisperNotes.pop();
                    
                    console.log("悄悄话已生成:", newNote);

                    // 如果当前正好开着悄悄话弹窗，立即刷新界面
                    if(document.getElementById('whisperModal').style.display === 'flex') {
                        renderWhisperNotes();
                    }
                }
                
                // 统一保存一次数据
                saveData();
            }
        }
    } catch(e) {
        console.error("生成心声/悄悄话失败", e);
    }
}

        // 新增：自动总结 (强化版)
        async function checkAutoSummary(config) {
            if (!currentChar.autoSummary) return;
            const threshold = currentChar.autoSummaryThreshold || 100;
            const len = currentChar.history.length;
            if (len > 0 && len % threshold === 0) {
                const fetchUrl = config.url.endsWith('/') ? config.url + 'v1/chat/completions' : config.url + '/v1/chat/completions';
                // 取最近 threshold 条进行总结
                const recent = currentChar.history.slice(-threshold).map(m => `${m.role}:${m.content}`).join('\n');
                try {
                    const res = await fetch(fetchUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.key}` },
                        body: JSON.stringify({
                            model: config.model,
                            messages: [
                                {role: "system", content: "你是一个专业的记忆助手。请根据以下对话，总结出关键信息。总结必须包含：1.时间(大概发生时候) 2.人物(谁和谁) 3.事件(发生了什么) 4.约定或重要细节。请用简洁的语言总结，字数控制在150字以内，不要遗漏重要情节。"},
                                {role: "user", content: recent}
                            ],
                            temperature: 0.5
                        })
                    });
                    if(res.ok) {
                        const data = await res.json();
                        const summary = `[自动总结 ${new Date().toLocaleString()}]: ` + data.choices[0].message.content;
                        if(!currentChar.longTermMemories) currentChar.longTermMemories = [];
                        currentChar.longTermMemories.push(summary);
                        saveData();
                    }
                } catch(e) {}
            }
        }

        // 1. 切换语音文字显示
function toggleVoiceText(el) {
    const textDiv = el.nextElementSibling;
    if (textDiv) textDiv.classList.toggle('show');
}

// 2. 查看图片描述
function showImageDesc(desc) {
    document.getElementById('imageViewText').innerText = desc;
    document.getElementById('imageViewModal').style.display = 'flex';
}

// 3. 处理转账卡片点击 (修改版)
function handleTransferClick(index, isMe) {
    const msg = currentChar.history[index];
    if (!msg || msg.msgType !== 'transfer') return;
    
    let data = {};
    try { data = JSON.parse(msg.content); } catch(e) { return; }

    // 只有当：是对方发给我的(!isMe)，且状态是 pending (未处理) 时
    if (!isMe && data.status === 'pending') {
        // 记录当前点击的是哪条消息
        tempTransferIndex = index;
        // 【关键点】这里必须显示弹窗，给用户选择的权力
        document.getElementById('userReceiveTransferModal').style.display = 'flex';
    }
}

// 新增：用户在弹窗点击 收取 或 拒收 后的逻辑
function confirmUserTransferAction(action) {
    // 关闭弹窗
    document.getElementById('userReceiveTransferModal').style.display = 'none';
    
    // 校验数据
    if (tempTransferIndex === -1 || !currentChar) return;
    const msg = currentChar.history[tempTransferIndex];
    if (!msg) return;

    // --- 1. 修改对方那条消息的状态（变为已收/已退）---
    let data = JSON.parse(msg.content);
    data.status = action; // 'accepted' 或 'returned'
    msg.content = JSON.stringify(data);
    
    // --- 2. 钱包处理（只在收款时加钱）---
    if (action === 'accepted') {
        updateWalletBalance(parseFloat(data.amount), `收到 ${currentChar.name} 转账`);
    } 
    // 如果是 refused/returned，不需要扣钱也不需要加钱

    // --- 3. 生成我的回复气泡（关键修改）---
    let noteText = action === 'accepted' ? '已收款' : '已退还';
    
    // 构造回复气泡的数据
    let replyContent = JSON.stringify({
        amount: data.amount, 
        note: noteText, 
        status: action 
    });

    // 插入一条“我”发送的转账类型消息
    currentChar.history.push({
        role: 'user',         // 角色是我
        msgType: 'transfer',  // 类型是转账卡片
        content: replyContent, 
        timestamp: Date.now() 
    });
    
    // --- 4. 保存并刷新 ---
    tempTransferIndex = -1;
    saveData();
    renderChat(activeChatId);
}

// 4. 角色处理用户转账的逻辑 (被 AI 触发)
function aiProcessTransfer(action) {
    if (!currentChar) return;
    // 倒序查找最后一条用户发给角色的 pending 转账
    for (let i = currentChar.history.length - 1; i >= 0; i--) {
        const msg = currentChar.history[i];
        // 必须是：用户发的(role=user)，类型是转账，状态是pending
        if (msg.role === 'user' && msg.msgType === 'transfer') {
            let data = JSON.parse(msg.content);
            if (data.status === 'pending') {
                data.status = action; // 'accepted' 或 'returned'
                msg.content = JSON.stringify(data);

                if (action === 'returned') {
                    updateWalletBalance(parseFloat(data.amount), `${currentChar.name} 退回转账`);
                }
                
                // 角色发送对应的反馈卡片
                let noteText = action === 'accepted' ? '已收款' : '已退还';
                let replyContent = JSON.stringify({
                    amount: data.amount, 
                    note: noteText, 
                    status: action 
                });
                
                currentChar.history.push({
                    role: 'assistant', 
                    msgType: 'transfer', 
                    content: replyContent, 
                    timestamp: Date.now()
                });
                
                saveData();
                renderChat(activeChatId);
                return; // 处理完一条就结束
            }
        }
    }
}

// 5. 弹窗按钮的处理函数 (对应HTML里的 onclick="handleTransferAction")
function handleTransferAction(action) {
    document.getElementById('charTransferActionModal').style.display = 'none';
    // 这个函数其实是留给用户手动操作的，但既然我们交给AI全自动判断，
    // 这里暂时留空或者仅作测试用。
    // 在本逻辑中，角色收不收钱完全由 triggerAiReply 中的 prompt 决定，
    // 这里的弹窗其实在你的需求里被 AI 自动化替代了，但保留着防止报错。
}

/* --- 悄悄话 (Whisper) 功能函数 --- */

let noteToDeleteId = null; // 暂存要删除的便签ID

// 1. 打开弹窗
function openWhisperModal() {
    if(!currentChar) return;
    
    // 生成背景星星 (每次打开随机生成位置)
    const starsContainer = document.getElementById('starsBg');
    starsContainer.innerHTML = '';
    for(let i=0; i<15; i++) { // 生成15颗星星
        const star = document.createElement('div');
        star.className = 'star-deco';
        // 随机位置、大小、延迟
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        const size = 15 + Math.random() * 35; // 让星星大一点，范围 15px - 50px
        star.style.width = size + 'px';
        star.style.height = size + 'px';
        star.style.animationDelay = Math.random() * 2 + 's';
        starsContainer.appendChild(star);
    }

    renderWhisperNotes();
    document.getElementById('whisperModal').style.display = 'flex';
}

// 2. 渲染便签墙
function renderWhisperNotes() {
    const container = document.getElementById('whisperNoteWall');
    container.innerHTML = '';

    const notes = currentChar.whisperNotes || [];

    if (notes.length === 0) {
        container.innerHTML = '<div style="grid-column: span 2; text-align:center; color:#999; margin-top:50px;">暂时还没有悄悄话哦~<br>多聊聊天就会有了</div>';
        return;
    }

    notes.forEach(note => {
        const div = document.createElement('div');
        // 组合 class: 基础 + 背景样式 + 旋转方向
        div.className = `sticky-note ${note.bgStyle} ${note.rotateClass}`;
        
        // 构建内容 HTML
        let contentHtml = `<span class="${note.textStyle} ${note.specialEffect || ''}">${note.text}</span>`;
        
        // 右上角删除按钮
        const deleteBtn = `<div class="note-delete-btn" onclick="askDeleteNote(${note.id})">×</div>`;
        
        div.innerHTML = deleteBtn + contentHtml;
        container.appendChild(div);
    });
}

// 3. 询问删除
function askDeleteNote(id) {
    noteToDeleteId = id;
    document.getElementById('deleteNoteConfirmModal').style.display = 'flex';
}

// 4. 确认删除
function confirmDeleteNote() {
    if(noteToDeleteId && currentChar) {
        // 过滤掉该ID的便签
        currentChar.whisperNotes = currentChar.whisperNotes.filter(n => n.id !== noteToDeleteId);
        saveData();
        renderWhisperNotes(); // 刷新界面
    }
    document.getElementById('deleteNoteConfirmModal').style.display = 'none';
    noteToDeleteId = null;
}

        msgInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendUserMsg(); });
    </script>

</body>
</html>
